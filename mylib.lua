mylib = {}
		-- Form https://wicc123.com/mylib  代码后面有使用说明见：https://wicc123.com/lua
		-- Use https://github.com/GitHubbard/wicc-contract-ext-lua/blob/master/context.lua
	mylib.constant = "cndx MyLib v1.6.8"
	GetCurTxAccount="wWwXa6uuaBpL8JGuxvJUmYpThZBqCZKxpv"	--调用合约的用户地址	_G._C.GetCurTxAddr()
	GetCurTxPayAmount=100012222					--调用合约时向其转入WICC额  _G._C.GetCurTxPayAmount()
	AssetGetNetAsset=21000033330006			--指定地址中WICC币可用余额  _G.Asset.GetNetAsset(address)
	AssetGetAppAsset=33000022220000			--指定地址中代币可用余额   _G.Asset.GetAppAsset(address)	
	ReadnilData="needVote0616,freeMulti0033,pColorB,pStateB"	--将变量名称放在这，则读取数据时为空
	ReadDataconfig="config,sets,symbol"			--变量名称放在，读取数据时第一次为空，第二次则非空
	mylib.ReadDataTable=true				--若设为false需要下方的mylib.ReadData的返回时不加{}
	
	function mylib.ReadData(param)
		print("ReadData form param: " , param)
		if param=="mykeys" then				--特定key返回读取下面数据		_G.AppData.Read(key)
			local readstr="myvalue"
			local readstrTbl = {string.byte(readstr,1,string.len(readstr))}
			return readstrTbl
		elseif param=="pColorA" then			--特定key返回读取下面数据
			return {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,0x14,0x16,0x18,0x1A,0x1C,0x1E,0x20,0x22,0x24,0x26,0x28,0x2A,0x2C,0x2E,0x30,0x32,0x34,0x36,0x38,0x3A,0x3C,0x03,0x06,0x09,0x0C,0x0F,0x12,0x15,0x18,0x1B,0x1E,0x21,0x24,0x27,0x2A,0x2D,0x30,0x33,0x36,0x39,0x3C,0x3F,0x42,0x45,0x48,0x4B,0x4E,0x51,0x54,0x57,0x5A,0x04,0x08,0x0C,0x10,0x14,0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x05,0x0A,0x0F,0x14,0x19,0x1E,0x23,0x28,0x2D,0x32,0x37,0x3C,0x41,0x46,0x4B,0x50,0x55,0x5A,0x5F,0x64,0x69,0x6E,0x73,0x78,0x7D,0x82,0x87,0x8C,0x91,0x96,0x06,0x0C,0x12,0x18,0x1E,0x24,0x2A,0x30,0x36,0x3C,0x42,0x48,0x4E,0x54,0x5A,0x60,0x66,0x6C,0x72,0x78,0x7E,0x84,0x8A,0x90,0x96,0x9C,0xA2,0xA8,0xAE,0xB4,0x07,0x0E,0x15,0x1C,0x23,0x2A,0x31,0x38,0x3F,0x46,0x4D,0x54,0x5B,0x62,0x69,0x70,0x77,0x7E,0x85,0x8C,0x93,0x9A,0xA1,0xA8,0xAF,0xB6,0xBD,0xC4,0xCB,0xD2,0x08,0x10,0x18,0x20,0x28,0x30,0x38,0x40,0x48,0x50,0x58,0x60,0x68,0x70,0x78,0x80,0x88,0x90,0x98,0xA0,0xA8,0xB0,0xB8,0xC0,0xC8,0xD0,0x00,0x08,0x10,0x18,0x09,0x12,0x1B,0x24,0x2D,0x36,0x3F,0x48,0x51,0x5A,0x63,0x6C,0x75,0x7E,0x87,0x90,0x99,0xA2,0xAB,0xB4,0xBD,0xC6,0xCF,0x00,0x09,0x12,0x1B,0x24,0x2D,0x36,0x0A,0x14,0x1E,0x28,0x32,0x3C,0x46,0x50,0x5A,0x64,0x6E,0x78,0x82,0x8C,0x96,0xA0,0xAA,0xB4,0xBE,0xC8,0xD2,0x04,0x0E,0x18,0x22,0x2C,0x36,0x40,0x4A,0x54,0x0B,0x16,0x21,0x2C,0x37,0x42,0x4D,0x58,0x63,0x6E,0x79,0x84,0x8F,0x9A,0xA5,0xB0,0xBB,0xC6,0xD1,0x04,0x0F,0x1A,0x25,0x30,0x3B,0x46,0x51,0x5C,0x67,0x72,0x0C,0x18,0x24,0x30,0x3C,0x48,0x54,0x60,0x6C,0x78,0x84,0x90,0x9C,0xA8,0xB4,0xC0,0xCC,0x00,0x0C,0x18,0x24,0x30,0x3C,0x48,0x54,0x60,0x6C,0x78,0x84,0x90,0x0D,0x1A,0x27,0x34,0x41,0x4E,0x5B,0x68,0x75,0x82,0x8F,0x9C,0xA9,0xB6,0xC3,0xD0,0x05,0x12,0x1F,0x2C,0x39,0x46,0x53,0x60,0x6D,0x7A,0x87,0x94,0xA1,0xAE,0x0E,0x1C,0x2A,0x38,0x46,0x54,0x62,0x70,0x7E,0x8C,0x9A,0xA8,0xB6,0xC4,0xD2,0x08,0x16,0x24,0x32,0x40,0x4E,0x5C,0x6A,0x78,0x86,0x94,0xA2,0xB0,0xBE,0xCC,0x0F,0x1E,0x2D,0x3C,0x4B,0x5A,0x69,0x78,0x87,0x96,0xA5,0xB4,0xC3,0xD2,0x09,0x18,0x27,0x36,0x45,0x54,0x63,0x72,0x81,0x90,0x9F,0xAE,0xBD,0xCC,0x03,0x12,0x10,0x20,0x30,0x40,0x50,0x60,0x70,0x80,0x90,0xA0,0xB0,0xC0,0xD0,0x08,0x18,0x28,0x38,0x48,0x58,0x68,0x78,0x88,0x98,0xA8,0xB8,0xC8,0x00,0x10,0x20,0x30,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0x05,0x16,0x27,0x38,0x49,0x5A,0x6B,0x7C,0x8D,0x9E,0xAF,0xC0,0xD1,0x0A,0x1B,0x2C,0x3D,0x4E,0x12,0x24,0x36,0x48,0x5A,0x6C,0x7E,0x90,0xA2,0xB4,0xC6,0x00,0x12,0x24,0x36,0x48,0x5A,0x6C,0x7E,0x90,0xA2,0xB4,0xC6,0x00,0x12,0x24,0x36,0x48,0x5A,0x6C,0x13,0x26,0x39,0x4C,0x5F,0x72,0x85,0x98,0xAB,0xBE,0xD1,0x0C,0x1F,0x32,0x45,0x58,0x6B,0x7E,0x91,0xA4,0xB7,0xCA,0x05,0x18,0x2B,0x3E,0x51,0x64,0x77,0x8A,0x14,0x28,0x3C,0x50,0x64,0x78,0x8C,0xA0,0xB4,0xC8,0x04,0x18,0x2C,0x40,0x54,0x68,0x7C,0x90,0xA4,0xB8,0xCC,0x08,0x1C,0x30,0x44,0x58,0x6C,0x80,0x94,0xA8,0x15,0x2A,0x3F,0x54,0x69,0x7E,0x93,0xA8,0xBD,0xD2,0x0F,0x24,0x39,0x4E,0x63,0x78,0x8D,0xA2,0xB7,0xCC,0x09,0x1E,0x33,0x48,0x5D,0x72,0x87,0x9C,0xB1,0xC6}
		elseif param=="pStateA" then			--特定key返回读取下面数据
			return {0x40,0x45,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40}
		elseif string.sub(param,1,6)=="pOwner" then			--特定key返回读取下面数据
			return {0x49,0x77,0x57,0x77,0x62,0x32,0x72,0x75,0x55,0x79,0x70,0x41,0x6D,0x46,0x41,0x74,0x38,0x76,0x57,0x73,0x53,0x33,0x46,0x36,0x77,0x6B,0x5A,0x66,0x47,0x70,0x62,0x31,0x59,0x4B,0x6D,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49,0x31,0x49}
		elseif string.sub(param,1,7)=="p2Owner" then			--特定key返回读取下面数据
			return nil
		elseif string.sub(param,1,7)=="p3Owner" then			--特定key返回读取下面数据
			return {}
		elseif string.sub(param,1,4)=="pTxt" then			--特定key返回读取下面数据
			return {0x7C,0x3E,0xAC,0x7C,0x3E,0x01,0x7C,0x3E,0x02,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E,0x7C,0x3E}
		elseif param=="allWicc" then			--特定key返回读取下面数据
			return {0x02,0x00,0x00,0x00}
		elseif param=="allPic" then				--特定key返回读取下面数据
			return {0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
		elseif string.sub(param,1,8)=="needVote" then	--特定key返回读取下面数据
			return {0x02,0x03,0x01,0x02,0x01}
		elseif string.find(ReadnilData,param) then
			return nil
		elseif string.find(ReadDataconfig,param) then
			rtnconfig=cfg
			cfg={0x50,0x49,0x43}
			return rtnconfig
		end
		return {0x61,0x62,0x63,0x00,0x10,0x00,0x00,0x00}	--默认返回的读取内容
	end
	function mylib.IntegerToByte8(param)
		bt={param%256}
		for i=2,8 do
			bt[i]=math.floor(param/256^(i-1))%256
		end
		return bt[1],bt[2],bt[3],bt[4],bt[5],bt[6],bt[7],bt[8]
	end
	function mylib.ByteToInteger(...)
		ints=0
		temp = {...}
		arg = select("1",temp) 
		assert(#arg == 4 or #arg == 8 , "ByteToInteger only 4 or 8, Byte len=" .. #arg )
		for i=1,#arg do
			ints=ints+arg[i]*256^(i-1)
		end
		return ints
	end
	function mylib.GetBase58Addr(param)
		a={}
		for i=1,34 do
			a[i]=string.byte(GetCurTxAccount,i)
		end
		return Unpack(a)
	end
	function mylib.GetCurTxAccount()
		return 0x61, 0x62, 0x63, 0x64, 0x65, 0x66
	end
	function mylib.GetCurTxPayAmount()
		bt={GetCurTxPayAmount%256}
		for i=2,8 do
			bt[i]=math.floor(GetCurTxPayAmount/256^(i-1))%256
		end
		return bt[1],bt[2],bt[3],bt[4],bt[5],bt[6],bt[7],bt[8]
	end
	function mylib.GetUserAppAccValue(param)
		bt={AssetGetAppAsset%256}
		for i=2,8 do
			bt[i]=math.floor(AssetGetAppAsset/256^(i-1))%256
		end
		return bt[1],bt[2],bt[3],bt[4],bt[5],bt[6],bt[7],bt[8]
	end
	function mylib.LogPrint(logTable)
		print("LogPrint" , logTable.key , logTable.value)
	end
	function mylib.WriteOutAppOperate(param)
		print("WriteOutAppOperate ",param," param.userIdLen ",param.userIdLen)
		return true
	end
	function mylib.WriteOutput(param)
		print("WriteOutput ",param)
		return true
	end
	function mylib.GetScriptID()
		return 0x01, 0x02, 0x03, 0x04, 0x05, 0x06
	end
	function mylib.GetContractRegId()
		return 0x01, 0x02, 0x03, 0x04, 0x05, 0x06
	end
	function mylib.ModifyData(param)
		print("ModifyData: param.value" , param.value)
		return true
	end
	function mylib.WriteData(writeDbTbl)
		print("WriteDataKey:", writeDbTbl.key,"  #["..writeDbTbl.length.."]")
		return true
	end
	function mylib.DeleteData(deleteDbTbl)
		print("DeleteDataKey:", deleteDbTbl.key)
		return true
	end
	function mylib.QueryAccountBalance(param)
		bt={AssetGetNetAsset%256}
		for i=2,8 do
			bt[i]=math.floor(AssetGetNetAsset/256^(i-1))%256
		end
		return bt[1],bt[2],bt[3],bt[4],bt[5],bt[6],bt[7],bt[8]
	end
	function mylib.GetTxContract(param)
		a={}
		print(string.format("MK add   %02X",param))
		if param==0x1c then
			strs='  _G.Context={ Event={}, Init=function(...) assert(contract or _G._err(0000,CallFunc),_G._errmsg) for k,v in pairs({ ... }) do if v.Init~=nil then v.Init() end end end, LoadContract=function() if #contract>0 then CallDomain=contract[1] CallFunc=contract[2] end end, Main=function() _G._C=_G.Context _G._C.LoadContract() if _G._C.Event[CallDomain] and _G._C.Event[CallDomain][CallFunc] then _G._C.Event[CallDomain][CallFunc]() else assert(_G._err(0404,CallFunc),_G._errmsg) end end}_G.Asset={}'
			end
		if param==0x3e then
			strs='  k="get it ok"'
		end
		if param==160 then
			strs="  _G.Hex = { Posit = 1, New = function(s, d) local mt = {} if (type(d) == 'string' ) then for i = 1, #d do table.insert(mt, string.byte(d, i)) end elseif d ~= nil then mt = d end setmetatable(mt, s) s.__index = s s.__eq = _G.Hex.__eq s.__tostring = _G.Hex.ToString s.__concat = _G.Hex.__concat return mt end, Appand = function(s, t) for i=1,#t do s[#s+1] = t[i] end return s end, Embed = function(s,start,t) for i=1,#t do s[i+start-1] = t[i] end return s end, Select = function(s, start, lens) assert((#s >= start + lens - 1) or _G._err(0004),_G._errmsg) local newt = {} for i=1,lens do newt[i] = s[start+i-1] end return _G.Hex:New(newt) end, Skip = function(s, count) local newt = {} for i=1,#s do newt[i] = s[count + i] end return _G.Hex:New(newt) end, Take = function(s, lens) local newt = {} for i=1,lens do newt[i] = s[i] end return _G.Hex:New(newt) end, Next = function(s, lens) local newt = {} for i=1,lens do assert(#s >= s.Posit or _G._err(0004),_G._errmsg) newt[i] = s[s.Posit] s.Posit = s.Posit + 1 end return _G.Hex:New(newt) end, IsEmpty = function(s) return #s==0 end, IsEmptyOrNil = function(s) return _G.next(s) == nil or #s == 0 end, ToString = function(s) return string.char(Unpack(s)) end, ToHexString = function(s) local str = '' for i=1,#s do str = str .. string.format('%02X', s[i]) end return str end, ToInt = function(s) local s= _G.Hex:New(s) if #s<4 then s=s:Appand({0x00,0x00,0x00}):Take(4) elseif #s>4 and #s<8 then s=s:Appand({0x00,0x00,0x00}):Take(8) end assert(#s==4 or #s==8 or _G._err(0001,#s),_G._errmsg) return _G.mylib.ByteToInteger(Unpack(s)) end, ToUInt = function(s) local value=s:ToInt() assert(value>=0 or _G._err(0105,value),_G._errmsg) return value end, Unpack = function(s) return _G.Hex.__expand(s) end, __fillloop=function(s,t) local endPosit = #s if t.Loop < 0 then t.Loop = s:Next(math.abs(t.Loop)):ToInt() end if t.Loop > 0 then endPosit = s.Posit+(t.Loop*t.Len)-1 end local subt = {} while endPosit>=s.Posit do local cell = s:Next(t.Len) if t.Model then cell = cell:Fill(t.Model) end table.insert(subt, cell) end return subt end, __expand = function(t, i) i = i or 1 if t[i] then return t[i], _G.Hex.__expand(t, i + 1) end end, __concat = function(s, t) return s:ToString()..t end, __eq = function(s, t) if (#s ~= #t) then return false end for i = #s, 1, -1 do if s[i] ~= t[i] then return false end end return true end }"
			end
			if param==0x5c then
			strs="  _G.Hex={New=function(s,d) local mt={} if (type(d)=='string') then for i=1,#d do table.insert(mt,string.byte(d,i)) end elseif d~=nil then mt=d end setmetatable(mt,s) s.__index=s s.__eq=_G.Hex.__eq s.__tostring=_G.Hex.ToString s.__concat=_G.Hex.__concat return mt end, ToString=function(s) return string.char(Unpack(s)) end, __concat=function(s,t) return s:ToString()..t end, __eq=function(s,t) if #s~=#t then return false end for i=#s,1,-1 do if s[i]~=t[i] then return false end end return true end}"
			end
			if param==0xa8 then
			strs="  _G.Hex.Posit=1 _G.Hex.Appand=function(s,t) for i=1,#t do s[#s+1]=t[i] end return s end _G.Hex.Select=function(s,start,lens) local nt={} for i=1,lens do nt[i]=s[start+i-1] end return _G.Hex:New(nt) end _G.Hex.Skip=function(s,count) local nt={} for i=1,#s do nt[i]=s[count+i] end return _G.Hex:New(nt) end _G.Hex.Next=function(s,lens) local nt={} for i=1,lens do nt[i]=s[s.Posit] s.Posit=s.Posit+1 end return _G.Hex:New(nt) end _G.Hex.IsEmptyOrNil=function(s) return _G.next(s)==nil or #s==0 end"
				end
			if param==0xf2 then
			strs="  _G.Hex.ToInt=function(s) local s=_G.Hex:New(s) s=s:Appand({0x00,0x00,0x00}) if #s<8 then s=s:Select(1,4) else s=s:Select(1,8) end return _G.mylib.ByteToInteger(Unpack(s)) end _G.Hex.__fillloop=function(s,t) local endPosit=#s if t.Loop<0 then t.Loop=s:Next(math.abs(t.Loop)):ToInt() end if t.Loop>0 then endPosit=s.Posit+(t.Loop*t.Len)-1 end local subt={} while endPosit>=s.Posit do local cell=s:Next(t.Len) if t.Model then cell=cell:Fill(t.Model) end table.insert(subt,cell) end return subt end"
				end
			if param==0xe6 then
			strs="   _G.Hex.Fill=function(s,t) local fd={} if t.Loop then fd=s:__fillloop(t) else for i=1,#t,2 do local k=t[i] local v=t[i+1] if type(v)=='table' then if v.Loop then fd[k]=s:__fillloop(v) elseif #v==1 then fd[k]=s:Next(v[1]) elseif v.Len then local cell=s:Next(v.Len) if v.Model then cell=cell:Fill(v.Model) else cell=cell:Fill(v) end fd[k]=cell end elseif type(v)=='string' then fd[k]=s:Next(tonumber(v)):ToString() elseif type(v)=='number' then fd[k]=s:Next(v):ToInt() end end end return fd end"
			end
			if param==0x6d then
			strs="   _G.Hex.sFill=function(s,t) local fd={} if t.Loop then fd=s:__fillloop(t) else for k,v in pairs(t) do if type(v)=='table' then if t[k].Loop then if t[k].Loop<0 then t[k].Loop=s:Next(0-t[k].Loop):ToInt() end if t[k].Loop>0 then fd[k]=s:__fillloop(v) end else fd[k]=s:Next(v[1]) end elseif type(v)=='string' then fd[k]=s:Next(tonumber(v)):ToString() elseif type(v)=='number' then fd[k]=s:Next(v):ToInt() end end end return fd end"
			end
		if param==0x22 then
			strs="  _G.Context.GetCurTxAddr=function() if _G._C.CurTxAddr==nil then local addr=_G.Hex:New({_G.mylib.GetBase58Addr(_G.mylib.GetCurTxAccount())}) assert(addr:IsEmptyOrNil()==false or _G._err(0500,'GetBase58Addr'),_G._errmsg) _G._C.CurTxAddr=addr:ToString() end return _G._C.CurTxAddr end _G.Context.GetCurTxPayAmount=function() if _G._C.CurTxPayAmount==nil then local amount=_G.Hex:New({_G.mylib.GetCurTxPayAmount()}) _G._C.CurTxPayAmount=amount:ToInt() end return _G._C.CurTxPayAmount end"
				end
		if param==0xf9 then
			strs="   _G.AppData={ Read=function(key) return _G.Hex:New({_G.mylib.ReadData(key)}) end, Write=function(key,value) if type(value)=='string' then value=_G.Hex:New(value) elseif type(value)=='number' then value={_G.mylib.IntegerToByte8(value)} end local writeDbTbl={key=key,length=#value,value=value} assert(_G.mylib.WriteData(writeDbTbl) or _G._err(0500,'WriteAppData'),_G._errmsg) end, Delete = function(key) assert(_G.mylib.DeleteData(key) or _G._err(0500,'DeleteData'),_G._errmsg) end}"
			if mylib.ReadDataTable then			
			strs="   _G.AppData={ Read=function(key) return _G.Hex:New(_G.mylib.ReadData(key)) end, Write=function(key,value) if type(value)=='string' then value=_G.Hex:New(value) elseif type(value)=='number' then value={_G.mylib.IntegerToByte8(value)} end local writeDbTbl={key=key,length=#value,value=value} assert(_G.mylib.WriteData(writeDbTbl) or _G._err(0500,'WriteAppData'),_G._errmsg) end, Delete = function(key) assert(_G.mylib.DeleteData(key) or _G._err(0500,'DeleteData'),_G._errmsg) end}"
			end
			end
		if param==0x5b then
			strs="   _G.Asset.AddAppAsset=function(toAddr,money) if type(toAddr)=='string' then toAddr=_G.Hex:New(toAddr) end if type(money)=='number' then money=_G.Hex:New({_G.mylib.IntegerToByte8(money)}) end assert((#toAddr==34 and money:ToInt()>0) or _G._err(0105,'add'),_G._errmsg) local tb={operatorType=1, outHeight=0, moneyTbl=money, userIdLen=#toAddr, userIdTbl=toAddr, fundTagLen=0, fundTagTbl={}} assert(_G.mylib.WriteOutAppOperate(tb) or _G._err(0500,'WriteOutAppOperate'),_G._errmsg) return true end"
			end
			if param==0x9d then
				strs="   _G.Asset.SubAppAsset=function(fromAddr,money) if type(fromAddr)=='string' then fromAddr=_G.Hex:New(fromAddr) end if type(money)=='number' then money=_G.Hex:New({_G.mylib.IntegerToByte8(money)}) end assert((#toAddr==34 and money:ToInt()>0) or _G._err(0105,'sub'),_G._errmsg) local tb={operatorType=2, outHeight=0, moneyTbl=money, userIdLen=#toAddr, userIdTbl=toAddr, fundTagLen=0, fundTagTbl={}} assert(_G.mylib.WriteOutAppOperate(tb) or _G._err(0500,'WriteOutApp'),_G._errmsg) return true end"
			end				
		if param==0x49 then
			strs="   _G.Asset.FromToAppAsset=function(fA,tA,m) if type(fA)=='string' then fA=_G.Hex:New(fA) end if type(tA)=='string' then tA=_G.Hex:New(tA) end if type(m)=='number' then m=_G.Hex:New({_G.mylib.IntegerToByte8(m)}) end local tb={ operatorType=2, outHeight=0, moneyTbl=m, userIdLen=#fA, userIdTbl=fA, fundTagLen=0, fundTagTbl={} } assert(_G.mylib.WriteOutAppOperate(tb),_G._errmsg) tb.operatorType=1 tb.userIdLen=#tA tb.userIdTbl=tA assert(_G.mylib.WriteOutAppOperate(tb),_G._errmsg) return true end"
			end
			if param==0xf4 then
				strs="   _G.Asset.SendAppAsset=function(fAddr,tA,m) if type(fAddr)=='string' then fAddr=_G.Hex:New(fAddr) end if type(m)=='number' then m=_G.Hex:New({_G.mylib.IntegerToByte8(m)}) end assert(m:ToInt()>0 and _G.Asset.GetAppAsset(fAddr)>=m:ToInt(),_G._errmsg) _G.Asset.FromToAppAsset(fAddr,tA,m) end _G.Asset.GetAppAsset=function(addr) if type(addr)=='string' then addr=_G.Hex:New(addr) end local mtb=_G.Hex:New({_G.mylib.GetUserAppAccValue({idLen=#addr,idValueTbl=addr})}) return mtb:ToInt() end"
				end
		
		if param==0xb1 then
			strs="   _G.GetNetAsset = function(addr) if type(addr) == 'string' then addr = _G.Hex:New(addr) end assert(#addr == 34 or #addr == 6 or _G._err(0100,addr,#addr),_G._errmsg) local mtb = _G.Hex:New({_G.mylib.QueryAccountBalance(Unpack(addr))}) assert(#mtb > 0 or _G._err(0500,'QueryAccountBalance'),_G._errmsg) return mtb:ToInt() end if _G.Asset then _G.Asset.GetNetAsset=_G.GetNetAsset end"
			end
			if param==0x01 then
			strs="   _G.SendNetAsset=function(tA,m) if type(tA)=='string' then tA=_G.Hex:New(tA) end if type(m)=='number' then m=_G.Hex:New({_G.mylib.IntegerToByte8(m)}) end local tb={ addrType=(#tA==6 and 1) or 2, accountIdTbl=tA, operatorType=1, outHeight=0, moneyTbl=m} assert(_G.mylib.WriteOutput(tb),_G._errmsg) tb.addrType=1 tb.operatorType=2 tb.accountIdTbl={_G.mylib.GetContractRegId()} assert(m:ToInt()<=_G.GetNetAsset(tb.accountIdTbl),_G._errmsg) assert(_G.mylib.WriteOutput(tb),_G._errmsg) return true end"
				end
			if param==0xb3 then
			strs="  T2S=function(m) local p='[Tab#'..#m..':]{' for i=1,#m do if i~=1 then p=p..',' end y=type(m[i]) k=m[i] if y=='string' then k='\"'..m[i]..'\"' end if y=='table' then k=T2S(m[i]) end p=p..k end p=p..'}' return p end Log=function(m) t=type(m) if t=='table' then m=T2S(m) end if t=='nil' then m='nil' end if t=='boolean' then m=(m and 'true') or 'false' end m=''..m local c=contract if c[#c]==0xf0 then print(m) if c[#c-1]==0 then error(m) end else _G.mylib.LogPrint({key=0,length=#m,value=m}) end end"
			end
		for i=1,#strs do
			a[i]=string.byte(strs,i)
		end
		a[1]=0x20
		return Unpack(a)
	end


return mylib